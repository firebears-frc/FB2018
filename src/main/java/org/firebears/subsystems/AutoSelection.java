// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package org.firebears.subsystems;

import org.firebears.Robot;
import org.firebears.RobotMap;
import org.firebears.commands.*;
import org.firebears.commands.auto.DriveToDistanceCommand;
import org.firebears.commands.auto.movement.BothSideCrossAutoCommand;
import org.firebears.commands.auto.movement.LeftSideLeftScaleCommand;
import org.firebears.commands.auto.movement.LeftSideLeftSwitchCommand;
import org.firebears.commands.auto.movement.LeftSideRightScaleCommand;
import org.firebears.commands.auto.movement.LeftSideRightSwitchCommand;
import org.firebears.commands.auto.movement.LeftSideTwoCubeScaleCommand;
import org.firebears.commands.auto.movement.LeftSideTwoCubeSplitCommand;
import org.firebears.commands.auto.movement.MiddleSideLeftSwitchCommand;
import org.firebears.commands.auto.movement.MiddleSideRightSwitchCommand;
import org.firebears.commands.auto.movement.RightSideLeftScaleCommand;
import org.firebears.commands.auto.movement.RightSideLeftSwitchCommand;
import org.firebears.commands.auto.movement.RightSideRightScaleCommand;
import org.firebears.commands.auto.movement.RightSideRightSwitchCommand;
import org.firebears.commands.auto.movement.RightSideTwoCubeScaleCommand;
import org.firebears.commands.auto.movement.RightSideTwoCubeSplitCommand;

import edu.wpi.first.wpilibj.command.Command;
import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.networktables.NetworkTableInstance;
import edu.wpi.first.wpilibj.DriverStation;
import edu.wpi.first.wpilibj.SpeedControllerGroup;
import edu.wpi.first.wpilibj.drive.DifferentialDrive;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

import com.ctre.phoenix.motorcontrol.can.WPI_TalonSRX;

/**
 *
 */
public class AutoSelection extends Subsystem {

	final String LEFT = "Left";
	final String RIGHT = "Right";
	final String MIDDLE = "Middle";
	final String SWITCH = "Switch";
	final String SCALE = "Scale";
	final char R = 'R';
	final char L = 'L';

	String side;
	String priority;
	Boolean shouldCross;
	Boolean shouldSplit;

	Command leftSideLeftScale = new LeftSideLeftScaleCommand();
	Command leftSideRightScale = new LeftSideRightScaleCommand();
	Command leftSideLeftSwitch = new LeftSideLeftSwitchCommand();
	Command leftSideRightSwitch = new LeftSideRightSwitchCommand();
	Command rightSideLeftScale = new RightSideLeftScaleCommand();
	Command rightSideRightScale = new RightSideRightScaleCommand();
	Command rightSideLeftSwitch = new RightSideLeftSwitchCommand();
	Command rightSideRightSwitch = new RightSideRightSwitchCommand();
	Command middleSideLeftSwitch = new MiddleSideLeftSwitchCommand();
	Command middleSideRightSwitch = new MiddleSideRightSwitchCommand();
	Command bothSideCrossAuto = new BothSideCrossAutoCommand();
	
	Command leftSideTwoCubeScale = new LeftSideTwoCubeScaleCommand();
	Command leftSideTwoCubeSplit = new LeftSideTwoCubeSplitCommand();
	Command rightSideTwoCubeScale = new RightSideTwoCubeScaleCommand();
	Command rightSideTwoCubeSplit = new RightSideTwoCubeSplitCommand();

	public AutoSelection() {

	}

	public Command getAuto() {
		//
		Command selectedAuto = null;
		// String side = Robot.oi.joystick2.getRawButton(18) ? LEFT :
		// (Robot.oi.joystick2.getRawButton(17) ? RIGHT : MIDDLE);
		// System.out.println("Side: " + side);
		// String priority = Robot.oi.joystick2.getRawButton(15) ? SCALE : SWITCH;
		// System.out.println("Priority: " + priority);
		// Boolean shouldCross = Robot.oi.joystick2.getRawButton(16);
		// System.out.println("ShouldCross: " + shouldCross);

		boolean leftSide = Robot.oi.xbox2.getRawButton(3);
		boolean rightSide = Robot.oi.xbox2.getRawButton(2);
		boolean shouldCross = Robot.oi.xbox2.getRawButton(16);
		boolean scaleBool = Robot.oi.xbox2.getRawButton(15);
		boolean shouldSplit = Robot.oi.xbox2.getRawButton(8);

		String side = "";
		String priority = "";

		if (leftSide == true && rightSide == false) {
			RobotMap.side = "Left";
			side = LEFT;
		} else if (leftSide == false && rightSide == true) {
			RobotMap.side = "Right";
			side = RIGHT;

		} else if (leftSide == false && rightSide == false) {
			RobotMap.side = "Middle";
			side = MIDDLE;

		}

		if (scaleBool == false) {
			RobotMap.priority = "Switch";
			priority = SWITCH;
		} else if (scaleBool == true) {
			RobotMap.priority = "Scale";
			priority = SCALE;
		}

		if (shouldCross == true) {
			RobotMap.shouldCross = true;
			shouldCross = true;
		} else if (shouldCross == false) {
			RobotMap.shouldCross = false;
			shouldCross = false;
		}
		
		if (shouldSplit == true) {
			RobotMap.shouldSplit = true;
			shouldSplit = true;
		} else if (shouldSplit == false) {
			RobotMap.shouldSplit = false;
			shouldSplit = false;
		}
		
		System.out.println(side);
		System.out.println(priority);
		System.out.println(shouldCross);

		String gameData = DriverStation.getInstance().getGameSpecificMessage();

//		for (int i = 0; i < 100; i++) {
//			gameData = DriverStation.getInstance().getGameSpecificMessage();
//			if (gameData != null) {
//				break;
//			}
//			try {
//				Thread.sleep(20);
//			} catch (Exception e) {
//			}
//		}

		if (gameData == null) {
			gameData = "LLL";
			System.out.println("No game data retrieved");
		}
		
		switch (side) {

		// Robot on left side
		case LEFT:
			switch (priority) {

			// Scale as priority
			case SCALE:
				switch (gameData.charAt(1)) {

				// Scale on left
				case L:
					// Runs when robot on left, scale on left (works)
					System.out.println("Select auto: left side, left scale");
					selectedAuto = leftSideLeftScale;
					break;

				// Scale on right
				case R:
					if (shouldCross) {
						// Runs when robot on left, scale on right and allowed to cross (works)
						System.out.println("Select auto: left side, right scale");
						selectedAuto = leftSideRightScale;
					} else {
						if (gameData.charAt(0) == L) {
							// Runs when robot on left, scale on right and cannot cross
							System.out.println("Select auto: left side, left switch");
							selectedAuto = leftSideLeftSwitch;
						} else {
							// Runs when robot on left, switch & scale on right and cannot cross
							System.out.println("Select auto: cross auto line");
							selectedAuto = bothSideCrossAuto;
						}
					}
					break;
				}
				break;

			// Switch as priority
			case SWITCH:
				switch (gameData.charAt(0)) {

				// Switch on left
				case L:
					// Runs when robot on left, switch on left
					System.out.println("Select auto: left side, left switch");
					selectedAuto = leftSideLeftSwitch;
					break;

				// Switch on right
				case R:
					if (shouldCross) {
						// Runs when robot on left, switch on right and allowed to cross
						System.out.println("Select auto: left side, right switch");
						selectedAuto = leftSideRightSwitch;
					} else {
						if (gameData.charAt(1) == L) {
							// Runs when robot on left, switch on right, scale on left and cannot cross
							System.out.println("Select auto: left side, left scale");
							selectedAuto = leftSideLeftScale;
						} else {
							// Runs when robot on left, scale & switch on right and cannot cross
							System.out.println("Select auto: cross auto line");
							selectedAuto = bothSideCrossAuto;
						}

					}
					break;
				}
				break;
			}
			break;

		// Robot is middle
		case MIDDLE:
			switch (gameData.charAt(0)) {

			// Switch on left
			case L:
				// Runs when robot is middle, switch on left
				System.out.println("Select auto: middle, left switch");
				selectedAuto = middleSideLeftSwitch;
				break;

			// Switch on right
			case R:
				// Runs when robot is middle, switch on right
				System.out.println("Select auto: middle, right switch");
				selectedAuto = middleSideRightSwitch;
				break;
			}
			break;

		// Robot on right side
		case RIGHT:
			switch (priority) {

			// Scale as priority
			case SCALE:
				switch (gameData.charAt(1)) {

				// Scale on right
				case R:
					// Runs when robot on right, scale on right
					System.out.println("Select auto: right side, right scale");
					selectedAuto = rightSideRightScale;
					break;

				// Scale on left
				case L:
					if (shouldCross) {
						// Runs when robot on right, scale on left and allowed to cross
						System.out.println("Select auto: right side, left scale");
						selectedAuto = rightSideLeftScale;
					} else {
						if (gameData.charAt(0) == R) {
							// Runs when robot on right, scale on left and cannot cross
							System.out.println("Select auto: right side, right switch");
							selectedAuto = rightSideRightSwitch;
						} else {
							// Runs when robot on right, switch & scale on left and cannot cross
							System.out.println("Select auto: cross auto line");
							selectedAuto = bothSideCrossAuto;
						}

					}
					break;
				}
				break;

			// Switch as priority
			case SWITCH:

				switch (gameData.charAt(0)) {

				// Switch on right
				case R:
					// Runs when robot on right, switch on right
					System.out.println("Select auto: right side, right switch");
					selectedAuto = rightSideRightSwitch;
					break;

				// Switch on left
				case L:
					if (shouldCross) {
						// Runs when robot on right, switch on left and allowed to cross
						System.out.println("Select auto: right side, left switch");
						selectedAuto = rightSideLeftSwitch;
					} else {
						if (gameData.charAt(1) == R) {
							// Runs when robot on right, switch on left, scale on right and not allowed to
							// cross
							System.out.println("Select Auto: right side, right scale");
							selectedAuto = rightSideRightScale;
						} else {
							// Runs when robot on right, switch & scale on left and not allowed to cross
							System.out.println("Select auto: cross auto line");
							selectedAuto = bothSideCrossAuto;
						}
					}
					break;
				}
				break;
			}
			break;
		}
		
		
		
		if (selectedAuto == leftSideLeftScale) {
			if (gameData.charAt(0) == L) {
				if (shouldSplit == true) {
					// Runs when robot on left, switch & scale on left, and put cube in both
					System.out.println("Select auto: left side, 2 cube, left switch and scale");
					selectedAuto = leftSideTwoCubeSplit;
					
				} else {
					// Runs when robot on left, scale on left, switch on right, put 2 cubes on scale
					System.out.println("Select auto: left side, 2 cube, left scale");
					selectedAuto = leftSideTwoCubeScale;
				}
				
			} else {
				// Runs when robot on left, scale on left, switch on right, put 2 cubes on scale
				System.out.println("Select auto: left side, 2 cube, left scale");
				selectedAuto = leftSideTwoCubeScale;
			}
			
		}
		
		if (selectedAuto == leftSideLeftSwitch) {
			if (gameData.charAt(1) == L) {
				if (shouldSplit == true) {
					// Runs when robot on left, switch & scale on left, and put cube in both
					System.out.println("Select auto: left side, 2 cube, left switch and scale");
					selectedAuto = leftSideTwoCubeSplit;
					
				} else {
					// Runs when robot on left, switch on left, scale on right, put 2 cubes on switch
					System.out.println("Select auto: left side, 2 cube, left switch");
					// Add command here
				}
				
			} else {
				// Runs when robot on left, switch on left, scale on right, put 2 cubes on switch
				System.out.println("Select auto: left side, 2 cube, left switch");
				// Add command here
			}
			
		}
		
		if (selectedAuto == rightSideRightScale) {
			if (gameData.charAt(0) == R) {
				if (shouldSplit == true) {
					// Runs when robot on right, switch & scale on right, and put cube in both
					System.out.println("Select auto: right side, 2 cube, right switch and scale");
					selectedAuto = rightSideTwoCubeSplit;
					
				} else {
					// Runs when robot on right, scale on right, switch on left, put 2 cubes on scale
					System.out.println("Select auto: right side, 2 cube, right scale");
					selectedAuto = rightSideTwoCubeScale;
				}
				
			} else {
				// Runs when robot on right, scale on right, switch on left, put 2 cubes on scale
				System.out.println("Select auto: right side, 2 cube, right scale");
				selectedAuto = rightSideTwoCubeScale;
			}
			
		}
		
		if (selectedAuto == rightSideRightSwitch) {
			if (gameData.charAt(1) == R) {
				if (shouldSplit == true) {
					// Runs when robot on right, switch & scale on right, and put cube in both
					System.out.println("Select auto: right side, 2 cube, right switch and scale");
					selectedAuto = rightSideTwoCubeSplit;
					
				} else {
					// Runs when robot on right, switch on right, scale on left, put 2 cubes on switch
					System.out.println("Select auto: right side, 2 cube, right switch");
					// Add command here
				}
				
			} else {
				// Runs when robot on right, switch on right, scale on left, put 2 cubes on switch
				System.out.println("Select auto: right side, 2 cube, right switch");
				// Add command here
			}
			
		}
		
		
		// If no command is selected, don't do anything
		if (selectedAuto == null) {
			System.out.println("No auto selected");
			selectedAuto = new DoNothingCommand();// Maybe replace with WaitCommand
		}

		return selectedAuto;
	}
	

	@Override
	public void initDefaultCommand() {
	}

	@Override
	public void periodic() {
		// if (RobotMap.DEBUG) {
		// SmartDashboard.putNumber("Throttle", Robot.oi.joystick2.getThrottle());
		// }
	}
}
