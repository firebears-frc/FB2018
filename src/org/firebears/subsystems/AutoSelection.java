// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package org.firebears.subsystems;

import org.firebears.Robot;
import org.firebears.RobotMap;
import org.firebears.commands.*;
import org.firebears.commands.auto.DriveToDistanceCommand;
import org.firebears.commands.auto.movement.BothSideCrossAutoCommand;
import org.firebears.commands.auto.movement.LeftSideLeftScaleCommand;
import org.firebears.commands.auto.movement.LeftSideLeftSwitchCommand;
import org.firebears.commands.auto.movement.LeftSideRightScaleCommand;
import org.firebears.commands.auto.movement.LeftSideRightSwitchCommand;
import org.firebears.commands.auto.movement.MiddleSideLeftSwitchCommand;
import org.firebears.commands.auto.movement.MiddleSideRightSwitchCommand;
import org.firebears.commands.auto.movement.RightSideLeftScaleCommand;
import org.firebears.commands.auto.movement.RightSideLeftSwitchCommand;
import org.firebears.commands.auto.movement.RightSideRightScaleCommand;
import org.firebears.commands.auto.movement.RightSideRightSwitchCommand;

import edu.wpi.first.wpilibj.command.Command;
import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.networktables.NetworkTableInstance;
import edu.wpi.first.wpilibj.DriverStation;
import edu.wpi.first.wpilibj.SpeedControllerGroup;
import edu.wpi.first.wpilibj.drive.DifferentialDrive;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

import com.ctre.phoenix.motorcontrol.can.WPI_TalonSRX;


/**
 *
 */
public class AutoSelection extends Subsystem {
	
	final String LEFT = "Left";
	final String RIGHT = "Right";
	final String MIDDLE = "Middle";
	final String SWITCH = "Switch";
	final String SCALE = "Scale";
	final char R = 'R';
	final char L = 'L';

	String side;
	String priority;
	Boolean shouldCross;
	
	Command leftSideLeftScale = new LeftSideLeftScaleCommand();
	Command leftSideRightScale = new LeftSideRightScaleCommand();
	Command leftSideLeftSwitch = new LeftSideLeftSwitchCommand();
	Command leftSideRightSwitch = new LeftSideRightSwitchCommand();
	Command rightSideLeftScale = new RightSideLeftScaleCommand();
	Command rightSideRightScale = new RightSideRightScaleCommand();
	Command rightSideLeftSwitch = new RightSideLeftSwitchCommand();
	Command rightSideRightSwitch = new RightSideRightSwitchCommand();
	Command middleSideLeftSwitch = new MiddleSideLeftSwitchCommand();
	Command middleSideRightSwitch = new MiddleSideRightSwitchCommand();
	Command bothSideCrossAuto = new BothSideCrossAutoCommand();
	
	
	public AutoSelection() {
		
	}
	

	public Command getAuto() {
//		
		Command selectedAuto = null;
//		String side = Robot.oi.joystick2.getRawButton(18) ? LEFT : (Robot.oi.joystick2.getRawButton(17) ? RIGHT : MIDDLE);
//		System.out.println("Side: " + side);
//		String priority = Robot.oi.joystick2.getRawButton(15) ? SCALE : SWITCH;
//		System.out.println("Priority: " + priority);
//		Boolean shouldCross = Robot.oi.joystick2.getRawButton(16);
//		System.out.println("ShouldCross: " + shouldCross);
		
		
		
		boolean leftSide = Robot.oi.joystick2.getRawButton(18);
		boolean rightSide = Robot.oi.joystick2.getRawButton(17);
		boolean shouldCross = Robot.oi.joystick2.getRawButton(16);
		boolean scaleBool = Robot.oi.joystick2.getRawButton(15);
		
		String side = "";
		String priority = "";


		if (leftSide == true && rightSide == false) {
			RobotMap.side = "Left";
			side = LEFT;
		} else if (leftSide == false && rightSide == true) {
			RobotMap.side = "Right";
			side = RIGHT;

		} else if (leftSide == false && rightSide == false) {
			RobotMap.side = "Middle";
			side = MIDDLE;

		}

		if (scaleBool == false) {
			RobotMap.priority = "Switch";
			priority = SWITCH;
		} else if (scaleBool == true) {
			RobotMap.priority = "Scale";
			priority = SCALE;
		}
		
		if (shouldCross == true) {
			RobotMap.shouldCross = true;
			shouldCross = true;
		} else if (shouldCross == false) {
			RobotMap.shouldCross = false;
			shouldCross = false;
		}
		System.out.println(side);
		System.out.println(priority);
		System.out.println(shouldCross);



		
		String gameData = DriverStation.getInstance().getGameSpecificMessage();

		
		
		if (gameData == null) {  gameData = "LLL"; System.out.println("No game data retrieved"); }
//		
		// to-do = replace println's with auto commands
		switch (side) {

		// Robot on left side
		case LEFT:
			switch (priority) {

			// Scale as priority
			case SCALE:
				switch (gameData.charAt(1)) {

				// Scale on left
				case L:
					// Runs when robot on left, scale on left (works)
					System.out.println("Select auto: left side, left scale");
					selectedAuto = leftSideLeftScale;
					break;

				// Scale on right
				case R:
					if (shouldCross) {
						// Runs when robot on left, scale on right and allowed to cross (works)
						System.out.println("Select auto: left side, right scale");
						selectedAuto = leftSideRightScale;
					} else {
						if (gameData.charAt(0) == L) {
							// Runs when robot on left, scale on right and cannot cross
							System.out.println("Select auto: left side, left switch");
							selectedAuto = leftSideLeftSwitch;
						} else {
							// Runs when robot on left, switch & scale on right and cannot cross
							System.out.println("Select auto: cross auto line");
							selectedAuto = bothSideCrossAuto;
						}
					}
					break;
				}
				break;

			// Switch as priority
			case SWITCH:
				switch (gameData.charAt(0)) {

				// Switch on left
				case L:
					// Runs when robot on left, switch on left
					System.out.println("Select auto: left side, left switch");
					selectedAuto = leftSideLeftSwitch;
					break;

				// Switch on right
				case R:
					if (shouldCross) {
						// Runs when robot on left, switch on right and allowed to cross
						System.out.println("Select auto: left side, right switch");
						selectedAuto = leftSideRightSwitch;
					} else {
						if (gameData.charAt(1) == L) {
							// Runs when robot on left, switch on right, scale on left and cannot cross
							System.out.println("Select auto: left side, left scale");
							selectedAuto = leftSideLeftScale;
						} else {
							// Runs when robot on left, scale & switch on right and cannot cross
							System.out.println("Select auto: cross auto line");
							selectedAuto = bothSideCrossAuto;
						}

					}
					break;
				}
				break;
			}
			break;

		// Robot is middle
		case MIDDLE:
			switch (gameData.charAt(0)) {

			// Switch on left
			case L:
				// Runs when robot is middle, switch on left
				System.out.println("Select auto: middle, left switch");
				selectedAuto = middleSideLeftSwitch;
				break;

			// Switch on right
			case R:
				// Runs when robot is middle, switch on right
				System.out.println("Select auto: middle, right switch");
				selectedAuto = middleSideRightSwitch;
				break;
			}
			break;

		// Robot on right side
		case RIGHT:
			switch (priority) {

			// Scale as priority
			case SCALE:
				switch (gameData.charAt(1)) {

				// Scale on right
				case R:
					// Runs when robot on right, scale on right
					System.out.println("Select auto: right side, right scale");
					selectedAuto = rightSideRightScale;
					break;
					
				// Scale on left
				case L:
					if (shouldCross) {
						// Runs when robot on right, scale on left and allowed to cross
						System.out.println("Select auto: right side, left scale");
						selectedAuto = rightSideLeftScale;
					} else {
						if (gameData.charAt(0) == R) {
							// Runs when robot on right, scale on left and cannot cross
							System.out.println("Select auto: right side, right switch");
							selectedAuto = rightSideRightSwitch;
						} else {
							// Runs when robot on right, switch & scale on left and cannot cross
							System.out.println("Select auto: cross auto line");
							selectedAuto = bothSideCrossAuto;
						}
						
					}
					break;
				}
				break;

			// Switch as priority
			case SWITCH:
				
				switch (gameData.charAt(0)) {
				
				// Switch on right
				case R:
					// Runs when robot on right, switch on right
					System.out.println("Select auto: right side, right switch");
					selectedAuto = rightSideRightSwitch;
					break;

				// Switch on left
				case L:
					if (shouldCross) {
						// Runs when robot on right, switch on left and allowed to cross
						System.out.println("Select auto: right side, left switch");
						selectedAuto = rightSideLeftSwitch;
					} else {
						if (gameData.charAt(1) == R) {
							// Runs when robot on right, switch on left, scale on right and not allowed to cross
							System.out.println("Select Auto: right side, right scale");
							selectedAuto = rightSideRightScale;
						} else {
							// Runs when robot on right, switch & scale on left and not allowed to cross
							System.out.println("Select auto: cross auto line");
							selectedAuto = bothSideCrossAuto;
						}
					}
					break;
				}
				break;
			}
			break;
		}
		// If no command is selected, don't do anything
		if (selectedAuto == null) {
			System.out.println("No auto selected");
			selectedAuto = new DoNothingCommand();// Maybe replace with WaitCommand
		}
		
		return selectedAuto;
	}

	@Override
	public void initDefaultCommand() {
	}

	@Override
	public void periodic() {
		if (RobotMap.DEBUG) {
		    SmartDashboard.putNumber("Throttle", Robot.oi.joystick2.getThrottle());
		}
	}
}
